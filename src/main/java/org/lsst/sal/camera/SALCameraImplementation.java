package org.lsst.sal.camera;

import java.time.Duration;
import java.time.Instant;
import org.lsst.sal.SAL_camera;

/**
 * An implementation of SALCamera which works by using the existing SAL
 * interface. This can be used as-is, but might be better generated by SAL.
 *
 * @author tonyj
 */
class SALCameraImplementation extends SALCamera {

    private final SAL_camera mgr;

    SALCameraImplementation() {
        mgr = new SAL_camera();
        //TODO: Some checks that connection was succesful, to prevent later
        // unexpected errors
        mgr.salProcessor("camera_command_setFilter");
        mgr.salProcessor("camera_command_takeImages");
        mgr.salProcessor("camera_command_initImage");
        mgr.salProcessor("camera_command_initGuiders");
        mgr.salProcessor("camera_command_enable");
        mgr.salProcessor("camera_command_disable");
        mgr.salProcessor("camera_command_enterControl");
        mgr.salProcessor("camera_command_exitControl");
        mgr.salProcessor("camera_command_start");
        mgr.salProcessor("camera_command_standby");
    }

    @Override
    @SuppressWarnings("SleepWhileInLoop")
    public CameraCommand getNextCommand(Duration timeout) throws SALException {
        Instant stop = Instant.now().plus(timeout);

        // Currently we have to poll for each command
        camera.command_setFilter setFilterCommand = new camera.command_setFilter();
        camera.command_takeImages takeImagesCommand = new camera.command_takeImages();
        camera.command_initImage initImageCommand = new camera.command_initImage();
        camera.command_initGuiders initGuidersCommand = new camera.command_initGuiders();
        camera.command_enable enableCommand = new camera.command_enable();
        camera.command_disable disableCommand = new camera.command_disable();
        camera.command_enterControl enterControlCommand = new camera.command_enterControl();
        camera.command_exitControl exitControlCommand = new camera.command_exitControl();
        camera.command_start startCommand = new camera.command_start();
        camera.command_standby standbyCommand = new camera.command_standby();

        while (!Instant.now().isAfter(stop)) {
            int cmdId = mgr.acceptCommand_setFilter(setFilterCommand);
            if (cmdId > 0) {
                return new SetFilterCommand(cmdId, mgr, setFilterCommand.name);
            }
            cmdId = mgr.acceptCommand_takeImages(takeImagesCommand);
            if (cmdId > 0) {
                return new TakeImagesCommand(cmdId, mgr, takeImagesCommand.expTime, takeImagesCommand.numImages, takeImagesCommand.shutter,
                        takeImagesCommand.science, takeImagesCommand.wfs, takeImagesCommand.guide, takeImagesCommand.imageSequenceName);
            }
            cmdId = mgr.acceptCommand_initImage(initImageCommand);
            if (cmdId > 0) {
                return new InitImageCommand(cmdId, mgr, initImageCommand.deltaT);
            }
            cmdId = mgr.acceptCommand_initGuiders(initGuidersCommand);
            if (cmdId > 0) {
                return new InitGuidersCommand(cmdId, mgr, initGuidersCommand.roiSpec);
            }
            cmdId = mgr.acceptCommand_enable(enableCommand);
            if (cmdId > 0) {
                return new EnableCommand(cmdId, mgr);
            }
            cmdId = mgr.acceptCommand_disable(disableCommand);
            if (cmdId > 0) {
                return new DisableCommand(cmdId, mgr);
            }
            cmdId = mgr.acceptCommand_enterControl(enterControlCommand);
            if (cmdId > 0) {
                return new EnterControlCommand(cmdId, mgr);
            }
            cmdId = mgr.acceptCommand_exitControl(exitControlCommand);
            if (cmdId > 0) {
                return new ExitControlCommand(cmdId, mgr);
            }
            cmdId = mgr.acceptCommand_start(startCommand);
            if (cmdId > 0) {
                return new StartCommand(cmdId, mgr, startCommand.configuration);
            }
            cmdId = mgr.acceptCommand_standby(standbyCommand);
            if (cmdId > 0) {
                return new StandbyCommand(cmdId, mgr);
            }
            try {
                // FIXME: Would be great if we did not have to poll
                Thread.sleep(10);
            } catch (InterruptedException ex) {
                throw new SALException("Unexpected interupt while polling for command", ex);
            }
        }
        return null; // Timeout
    }

    @Override
    public CommandResponse issueCommand(CameraCommand command) throws SALException {
        return command.issueCommand(mgr);
    }

    @Override
    public void logEvent(CameraEvent event) throws SALException {
        event.logEvent(mgr);
    }

    @Override
    @SuppressWarnings("SleepWhileInLoop")
    public CameraEvent getNextEvent(Duration timeout) throws SALException {
        Instant stop = Instant.now().plus(timeout);

        // Currently we have to poll for each event
        mgr.salEvent("camera_logevent_SummaryState");
        camera.logevent_SummaryState summaryStateEvent = new camera.logevent_SummaryState();

        while (!Instant.now().isAfter(stop)) {
            int rc = mgr.getEvent_SummaryState(summaryStateEvent);
            if (rc == SAL_camera.SAL__OK) {
                return new SummaryStateEvent(summaryStateEvent.priority, summaryStateEvent.SummaryStateValue);
            }
            try {
                // FIXME: Would be great if we did not have to poll
                Thread.sleep(10);
            } catch (InterruptedException ex) {
                throw new SALException("Unexpected interupt while polling for event", ex);
            }
        }
        return null; // Timeout        
    }

}
